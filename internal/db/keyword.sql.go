// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: keyword.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const deleteKeyword = `-- name: DeleteKeyword :one
DELETE FROM keywords
WHERE id = $1
RETURNING id, keyword
`

type DeleteKeywordRow struct {
	ID      int32  `json:"id"`
	Keyword string `json:"keyword"`
}

func (q *Queries) DeleteKeyword(ctx context.Context, id int32) (DeleteKeywordRow, error) {
	row := q.db.QueryRowContext(ctx, deleteKeyword, id)
	var i DeleteKeywordRow
	err := row.Scan(&i.ID, &i.Keyword)
	return i, err
}

const getCountsPerUserPerKeywordById = `-- name: GetCountsPerUserPerKeywordById :one
SELECT
  u.id AS user_id,
  u.username,
  json_build_object(
    'keywords', json_agg(
      json_build_object(
        'keyword_id', k.id,
        'keyword', k.keyword,
        'count', um.count
      )
    ),
    'total_count', SUM(um.count),
    'last_message', MAX(um.last_message),
    'fav_word', 
    (
      SELECT k2.keyword
      FROM user_messages um2
      JOIN keywords k2 ON um2.keyword_id = k2.id
      WHERE um2.user_id = u.id
      ORDER BY um2.count DESC
      LIMIT 1
    )
  ) AS stats
FROM users u
JOIN user_messages um ON um.user_id = u.id
JOIN keywords k ON um.keyword_id = k.id
WHERE u.id = $1
GROUP BY u.id, u.username
`

type GetCountsPerUserPerKeywordByIdRow struct {
	UserID   int32           `json:"user_id"`
	Username string          `json:"username"`
	Stats    json.RawMessage `json:"stats"`
}

func (q *Queries) GetCountsPerUserPerKeywordById(ctx context.Context, id int32) (GetCountsPerUserPerKeywordByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getCountsPerUserPerKeywordById, id)
	var i GetCountsPerUserPerKeywordByIdRow
	err := row.Scan(&i.UserID, &i.Username, &i.Stats)
	return i, err
}

const getGlobalKeywordsCount = `-- name: GetGlobalKeywordsCount :many
SELECT
  k.id AS keyword_id,
  k.keyword,
  k.active,
  COALESCE(SUM(um.count), 0) AS total_count
FROM
  keywords k
LEFT JOIN
  user_messages um ON um.keyword_id = k.id
  AND um.message_date BETWEEN $1 AND $2
WHERE k.streamer_id = $3
GROUP BY
  k.id, k.keyword, k.active
`

type GetGlobalKeywordsCountParams struct {
	MessageDate   time.Time `json:"message_date"`
	MessageDate_2 time.Time `json:"message_date_2"`
	StreamerID    int32     `json:"streamer_id"`
}

type GetGlobalKeywordsCountRow struct {
	KeywordID  int32         `json:"keyword_id"`
	Keyword    string        `json:"keyword"`
	Active     bool          `json:"active"`
	TotalCount sql.NullInt64 `json:"total_count"`
}

func (q *Queries) GetGlobalKeywordsCount(ctx context.Context, arg GetGlobalKeywordsCountParams) ([]GetGlobalKeywordsCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalKeywordsCount, arg.MessageDate, arg.MessageDate_2, arg.StreamerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalKeywordsCountRow
	for rows.Next() {
		var i GetGlobalKeywordsCountRow
		if err := rows.Scan(
			&i.KeywordID,
			&i.Keyword,
			&i.Active,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalKeywordsCountAsc = `-- name: GetGlobalKeywordsCountAsc :many
SELECT
  k.id AS keyword_id,
  k.keyword,
  k.active,
  COALESCE(SUM(um.count), 0) AS total_count
FROM
  keywords k
LEFT JOIN
  user_messages um
  ON um.keyword_id = k.id
GROUP BY
  k.id, k.keyword, k.active
ORDER BY
  total_count ASC
`

type GetGlobalKeywordsCountAscRow struct {
	KeywordID  int32         `json:"keyword_id"`
	Keyword    string        `json:"keyword"`
	Active     bool          `json:"active"`
	TotalCount sql.NullInt64 `json:"total_count"`
}

func (q *Queries) GetGlobalKeywordsCountAsc(ctx context.Context) ([]GetGlobalKeywordsCountAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalKeywordsCountAsc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalKeywordsCountAscRow
	for rows.Next() {
		var i GetGlobalKeywordsCountAscRow
		if err := rows.Scan(
			&i.KeywordID,
			&i.Keyword,
			&i.Active,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalKeywordsCountAscPaginated = `-- name: GetGlobalKeywordsCountAscPaginated :many
SELECT
  k.id AS keyword_id,
  k.keyword,
  k.active,
  COALESCE(SUM(um.count), 0) AS total_count
FROM
  keywords k
LEFT JOIN
  user_messages um
  ON um.keyword_id = k.id AND um.streamer_id = $1
WHERE
  um.message_date BETWEEN $2 AND $3
GROUP BY
  k.id, k.keyword, k.active
ORDER BY
  total_count ASC
LIMIT $4 OFFSET $5
`

type GetGlobalKeywordsCountAscPaginatedParams struct {
	StreamerID    sql.NullInt32 `json:"streamer_id"`
	MessageDate   time.Time     `json:"message_date"`
	MessageDate_2 time.Time     `json:"message_date_2"`
	Limit         int32         `json:"limit"`
	Offset        int32         `json:"offset"`
}

type GetGlobalKeywordsCountAscPaginatedRow struct {
	KeywordID  int32         `json:"keyword_id"`
	Keyword    string        `json:"keyword"`
	Active     bool          `json:"active"`
	TotalCount sql.NullInt64 `json:"total_count"`
}

func (q *Queries) GetGlobalKeywordsCountAscPaginated(ctx context.Context, arg GetGlobalKeywordsCountAscPaginatedParams) ([]GetGlobalKeywordsCountAscPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalKeywordsCountAscPaginated,
		arg.StreamerID,
		arg.MessageDate,
		arg.MessageDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalKeywordsCountAscPaginatedRow
	for rows.Next() {
		var i GetGlobalKeywordsCountAscPaginatedRow
		if err := rows.Scan(
			&i.KeywordID,
			&i.Keyword,
			&i.Active,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalKeywordsCountDesc = `-- name: GetGlobalKeywordsCountDesc :many
SELECT
  k.id AS keyword_id,
  k.keyword,
  k.active,
  COALESCE(SUM(um.count), 0) AS total_count
FROM
  keywords k
LEFT JOIN
  user_messages um ON um.keyword_id = k.id
  AND um.message_date BETWEEN $1 AND $2
GROUP BY
  k.id, k.keyword, k.active
ORDER BY
  total_count DESC
`

type GetGlobalKeywordsCountDescParams struct {
	MessageDate   time.Time `json:"message_date"`
	MessageDate_2 time.Time `json:"message_date_2"`
}

type GetGlobalKeywordsCountDescRow struct {
	KeywordID  int32         `json:"keyword_id"`
	Keyword    string        `json:"keyword"`
	Active     bool          `json:"active"`
	TotalCount sql.NullInt64 `json:"total_count"`
}

func (q *Queries) GetGlobalKeywordsCountDesc(ctx context.Context, arg GetGlobalKeywordsCountDescParams) ([]GetGlobalKeywordsCountDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalKeywordsCountDesc, arg.MessageDate, arg.MessageDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalKeywordsCountDescRow
	for rows.Next() {
		var i GetGlobalKeywordsCountDescRow
		if err := rows.Scan(
			&i.KeywordID,
			&i.Keyword,
			&i.Active,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalKeywordsCountDescPaginated = `-- name: GetGlobalKeywordsCountDescPaginated :many
SELECT
  k.id AS keyword_id,
  k.keyword,
  k.active,
  COALESCE(SUM(um.count), 0) AS total_count
FROM
  keywords k
LEFT JOIN
  user_messages um
  ON um.keyword_id = k.id AND um.streamer_id = $1
WHERE
  um.message_date BETWEEN $2 AND $3
GROUP BY
  k.id, k.keyword, k.active
ORDER BY
  total_count DESC
LIMIT $4 OFFSET $5
`

type GetGlobalKeywordsCountDescPaginatedParams struct {
	StreamerID    sql.NullInt32 `json:"streamer_id"`
	MessageDate   time.Time     `json:"message_date"`
	MessageDate_2 time.Time     `json:"message_date_2"`
	Limit         int32         `json:"limit"`
	Offset        int32         `json:"offset"`
}

type GetGlobalKeywordsCountDescPaginatedRow struct {
	KeywordID  int32         `json:"keyword_id"`
	Keyword    string        `json:"keyword"`
	Active     bool          `json:"active"`
	TotalCount sql.NullInt64 `json:"total_count"`
}

func (q *Queries) GetGlobalKeywordsCountDescPaginated(ctx context.Context, arg GetGlobalKeywordsCountDescPaginatedParams) ([]GetGlobalKeywordsCountDescPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalKeywordsCountDescPaginated,
		arg.StreamerID,
		arg.MessageDate,
		arg.MessageDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalKeywordsCountDescPaginatedRow
	for rows.Next() {
		var i GetGlobalKeywordsCountDescPaginatedRow
		if err := rows.Scan(
			&i.KeywordID,
			&i.Keyword,
			&i.Active,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalKeywordsCountPaginated = `-- name: GetGlobalKeywordsCountPaginated :many
SELECT
  k.id AS keyword_id,
  k.keyword,
  k.active,
  COALESCE(SUM(um.count), 0) AS total_count
FROM
  keywords k
LEFT JOIN
  user_messages um
  ON um.keyword_id = k.id
WHERE
  um.message_date BETWEEN $1 AND $2
GROUP BY
  k.id, k.keyword, k.active
ORDER BY
  k.id ASC
LIMIT $3 OFFSET $4
`

type GetGlobalKeywordsCountPaginatedParams struct {
	MessageDate   time.Time `json:"message_date"`
	MessageDate_2 time.Time `json:"message_date_2"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
}

type GetGlobalKeywordsCountPaginatedRow struct {
	KeywordID  int32         `json:"keyword_id"`
	Keyword    string        `json:"keyword"`
	Active     bool          `json:"active"`
	TotalCount sql.NullInt64 `json:"total_count"`
}

func (q *Queries) GetGlobalKeywordsCountPaginated(ctx context.Context, arg GetGlobalKeywordsCountPaginatedParams) ([]GetGlobalKeywordsCountPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalKeywordsCountPaginated,
		arg.MessageDate,
		arg.MessageDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalKeywordsCountPaginatedRow
	for rows.Next() {
		var i GetGlobalKeywordsCountPaginatedRow
		if err := rows.Scan(
			&i.KeywordID,
			&i.Keyword,
			&i.Active,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeywordById = `-- name: GetKeywordById :one
SELECT 
  k.id AS keyword_id,
  k.keyword,
  k.active,
  COALESCE(SUM(um.count), 0) AS total_count
FROM
  keywords k
LEFT JOIN
  user_messages um
  ON um.keyword_id = k.id
WHERE
  k.id = $1
GROUP BY
  k.id, k.keyword, k.active
`

type GetKeywordByIdRow struct {
	KeywordID  int32         `json:"keyword_id"`
	Keyword    string        `json:"keyword"`
	Active     bool          `json:"active"`
	TotalCount sql.NullInt64 `json:"total_count"`
}

func (q *Queries) GetKeywordById(ctx context.Context, id int32) (GetKeywordByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getKeywordById, id)
	var i GetKeywordByIdRow
	err := row.Scan(
		&i.KeywordID,
		&i.Keyword,
		&i.Active,
		&i.TotalCount,
	)
	return i, err
}

const getKeywordsByStreamer = `-- name: GetKeywordsByStreamer :many
SELECT
  k.id AS keyword_id,
  k.keyword,
  k.active,
  COALESCE(SUM(um.count), 0) AS total_count
FROM
  keywords k
LEFT JOIN
  user_messages um ON um.keyword_id = k.id
  AND um.streamer_id = $1
  AND um.message_date BETWEEN $2 AND $3
GROUP BY
  k.id, k.keyword, k.active
ORDER BY
  total_count DESC
`

type GetKeywordsByStreamerParams struct {
	StreamerID    sql.NullInt32 `json:"streamer_id"`
	MessageDate   time.Time     `json:"message_date"`
	MessageDate_2 time.Time     `json:"message_date_2"`
}

type GetKeywordsByStreamerRow struct {
	KeywordID  int32         `json:"keyword_id"`
	Keyword    string        `json:"keyword"`
	Active     bool          `json:"active"`
	TotalCount sql.NullInt64 `json:"total_count"`
}

func (q *Queries) GetKeywordsByStreamer(ctx context.Context, arg GetKeywordsByStreamerParams) ([]GetKeywordsByStreamerRow, error) {
	rows, err := q.db.QueryContext(ctx, getKeywordsByStreamer, arg.StreamerID, arg.MessageDate, arg.MessageDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKeywordsByStreamerRow
	for rows.Next() {
		var i GetKeywordsByStreamerRow
		if err := rows.Scan(
			&i.KeywordID,
			&i.Keyword,
			&i.Active,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertKeyword = `-- name: UpsertKeyword :one
INSERT INTO keywords (streamer_id, keyword, active)
VALUES ($1, $2, TRUE)
ON CONFLICT (streamer_id, keyword) DO UPDATE SET
    active = EXCLUDED.active
RETURNING id
`

type UpsertKeywordParams struct {
	StreamerID int32  `json:"streamer_id"`
	Keyword    string `json:"keyword"`
}

func (q *Queries) UpsertKeyword(ctx context.Context, arg UpsertKeywordParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertKeyword, arg.StreamerID, arg.Keyword)
	var id int32
	err := row.Scan(&id)
	return id, err
}
