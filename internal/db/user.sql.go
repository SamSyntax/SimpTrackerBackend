// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const getCountsPerUserPerKeywordByStreamer = `-- name: GetCountsPerUserPerKeywordByStreamer :many
SELECT
  u.id AS user_id,
  u.username,
  json_build_object(
    'keywords', json_agg(
      json_build_object(
        'keyword_id', k.id,
        'keyword', k.keyword,
        'count', um.count
      )
    ),
    'total_count', SUM(um.count),
    'last_message', MAX(um.last_message),
    'fav_word', 
    (
      SELECT k2.keyword
      FROM user_messages um2
      JOIN keywords k2 ON um2.keyword_id = k2.id
      WHERE um2.user_id = u.id AND um2.streamer_id = $1
      ORDER BY um2.count DESC
      LIMIT 1
    )
  ) AS stats
FROM users u
JOIN user_messages um ON um.user_id = u.id
JOIN keywords k ON um.keyword_id = k.id
WHERE um.streamer_id = $1
GROUP BY u.id, u.username
ORDER BY SUM(um.count) DESC
`

type GetCountsPerUserPerKeywordByStreamerRow struct {
	UserID   int32           `json:"user_id"`
	Username string          `json:"username"`
	Stats    json.RawMessage `json:"stats"`
}

func (q *Queries) GetCountsPerUserPerKeywordByStreamer(ctx context.Context, streamerID sql.NullInt32) ([]GetCountsPerUserPerKeywordByStreamerRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountsPerUserPerKeywordByStreamer, streamerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountsPerUserPerKeywordByStreamerRow
	for rows.Next() {
		var i GetCountsPerUserPerKeywordByStreamerRow
		if err := rows.Scan(&i.UserID, &i.Username, &i.Stats); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountsPerUserPerKeywordByUsername = `-- name: GetCountsPerUserPerKeywordByUsername :one
SELECT
  u.id AS user_id,
  u.username,
  json_build_object(
    'keywords', json_agg(
      json_build_object(
        'keyword_id', k.id,
        'keyword', k.keyword,
        'count', um.count
      )
    ),
    'total_count', SUM(um.count),
    'last_message', MAX(um.last_message),
    'fav_word', 
    (
      SELECT k2.keyword
      FROM user_messages um2
      JOIN keywords k2 ON um2.keyword_id = k2.id
      WHERE um2.user_id = u.id
      ORDER BY um2.count DESC
      LIMIT 1
    )
  ) AS stats
FROM users u
JOIN user_messages um ON um.user_id = u.id
JOIN keywords k ON um.keyword_id = k.id
WHERE u.username = $1
GROUP BY u.id, u.username
`

type GetCountsPerUserPerKeywordByUsernameRow struct {
	UserID   int32           `json:"user_id"`
	Username string          `json:"username"`
	Stats    json.RawMessage `json:"stats"`
}

func (q *Queries) GetCountsPerUserPerKeywordByUsername(ctx context.Context, username string) (GetCountsPerUserPerKeywordByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getCountsPerUserPerKeywordByUsername, username)
	var i GetCountsPerUserPerKeywordByUsernameRow
	err := row.Scan(&i.UserID, &i.Username, &i.Stats)
	return i, err
}

const getUsersWithTotalCounts = `-- name: GetUsersWithTotalCounts :many
SELECT
  u.id AS user_id,
  u.username,
  json_build_object(
    'keywords', json_agg(
      json_build_object(
        'keyword_id', k.id,
        'keyword', k.keyword,
        'count', um.count
      )
    ),
    'total_count', SUM(um.count),
    'last_message', MAX(um.last_message),
    'fav_word', 
    (
      SELECT k2.keyword
      FROM user_messages um2
      JOIN keywords k2 ON um2.keyword_id = k2.id
      WHERE um2.user_id = u.id
      ORDER BY um2.count DESC
      LIMIT 1
    )
  ) AS stats
FROM users u
JOIN user_messages um ON um.user_id = u.id
JOIN keywords k ON um.keyword_id = k.id
GROUP BY u.id, u.username
ORDER BY SUM(um.count) DESC
`

type GetUsersWithTotalCountsRow struct {
	UserID   int32           `json:"user_id"`
	Username string          `json:"username"`
	Stats    json.RawMessage `json:"stats"`
}

func (q *Queries) GetUsersWithTotalCounts(ctx context.Context) ([]GetUsersWithTotalCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithTotalCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithTotalCountsRow
	for rows.Next() {
		var i GetUsersWithTotalCountsRow
		if err := rows.Scan(&i.UserID, &i.Username, &i.Stats); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (username)
VALUES ($1)
ON CONFLICT (username) DO UPDATE SET username = EXCLUDED.username
RETURNING id
`

func (q *Queries) UpsertUser(ctx context.Context, username string) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertUser, username)
	var id int32
	err := row.Scan(&id)
	return id, err
}
